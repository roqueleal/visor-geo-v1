<html ‚ö°=""
lang="es">

<head>             
  <meta charset="utf-8">
  <title>Coronavirus Jujuy</title>
  <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
  <meta name="amp-google-client-id-api" content="googleanalytics">
  <meta name="description" content="üåé  Mapa Coronavirus : Eventos ProvinCia de Juju ‚úîÔ∏è">
  <link rel="shortcut icon" href="./img/icons/favicon.png">


    <!--Google fonts-->
    <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Spartan&display=swap" rel="stylesheet">

    <!--leaflet style-->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css"
          integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ=="
          crossorigin=""/>

    <!-- leaflet js. Make sure you put this AFTER Leaflet's CSS -->
    <script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet.js"
            integrity="sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew=="
            crossorigin=""></script>
    <!--sidebar style-->
    <link rel="stylesheet" href="assets/css/leaflet-sidebar.css" />
    <!--font awesome style-->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <!-- marker cluster styles-->
    <link rel="stylesheet" type="text/css" href="https://unpkg.com/leaflet.markercluster@1.0.4/dist/MarkerCluster.Default.css">
    <link rel="stylesheet" type="text/css" href="https://unpkg.com/leaflet.markercluster@1.0.4/dist/MarkerCluster.css">
    <!-- bootstrap css-->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <!--marker cluster javascript-->
    <script src="https://unpkg.com/leaflet.markercluster@1.0.4/dist/leaflet.markercluster.js"></script>
    <style>

        body { margin:0; padding:0; }
        #map { position:absolute; top:0; bottom:0; width:100%; }
        .leaflet-tooltip-pane .text {
            color:black;
            /*-webkit-text-stroke: 0.03em white;*/
            font-weight: bold;
            background: transparent;
            border:0;
            box-shadow: none;
            font-size: 1em;
        }

        /*/////////////////// Icono pulse ////////////////*/
        .fa-pulse {
            display: inline-block;
            -moz-animation: pulse 2s infinite linear;
            -o-animation: pulse 2s infinite linear;
            -webkit-animation: pulse 2s infinite linear;
            animation: pulse 2s infinite linear;
        }

        @-webkit-keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0; }
            100% { opacity: 1; }
        }
        @-moz-keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0; }
            100% { opacity: 1; }
        }
        @-o-keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0; }
            100% { opacity: 1; }
        }
        @-ms-keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0; }
            100% { opacity: 1; }
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0; }
            100% { opacity: 1; }
        }
        /*/////////////////Fin del Icono Pulse////////////////////*/
        .leaflet-popup-content {
            padding: 10px 10px 15px;
            margin: 0;
            line-height: inherit;
        }

        div.leaflet-popup-content-wrapper {
            background-color: rgb(238, 16, 101);
            color: white;
            font-size: 12px;
            font-family:'Ubuntu';
            border-radius: 3px;
            box-shadow: 0 1px 2px rgba(0,0,0,.1);
            padding: 1px;
            text-align: left;
            pointer-events: all;

        }
        .leaflet-sidebar-header {
            font-size: 15px;
        }
        /*Esta parte es para evitar la superposici√≥n en la barra lateral y el control de capas en pantallas m√°s peque√±as */
        @media (max-width: 769px) {
            .leaflet-sidebar-header {
                font-size: 13px;
            }
        }

        @media (max-width: 769px) {
            .leaflet-sidebar-content {
                opacity: 0.95 ;
            }
        }

        @media (max-width: 769px) {
            .leaflet-right .leaflet-control {
                margin-right: 60px;
            }
        }


        .leaflet-sidebar-header {
            background-color:rgb(36, 168, 230);


        }
        .leaflet-sidebar-header p{
            margin-bottom: 0px;
            margin-top: 0px;
        }
        .leaflet-sidebar-tabs > li.active, .leaflet-sidebar-tabs > ul > li.active {
            background-color:rgb(47, 60, 66);

        }


        .info {
            padding: 6px 8px;
            font-size: 13px;
            background: white;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }
        .info h4 {
            margin: 0 0 5px;
            color: #777;
        }
        .legend {
            text-align: left;
            line-height: 30px;
            color: #555;
            width: auto;
        }
        .legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 0.7;
        }
        .legend .colorcircle {
            border-radius: 50%;
            width: 15px;
            height: 15px;
            margin-top: 0px;
        }
        .legend .circlepadding {
            border-radius: 50%;
            margin-top: 0px;
            background: rgba(255, 255, 255, 0.8);
        }

        #container {
            height: 1800px;
        }

        .highcharts-data-table table {
            font-family: Verdana, sans-serif;
            border-collapse: collapse;
            border: 1px solid #EBEBEB;
            margin: 10px auto;
            text-align: center;
            width: 100%;
            max-width: 500px;
        }
        .highcharts-data-table caption {
            padding: 1em 0;
            font-size: 1.2em;
            color: #555;
        }
        .highcharts-data-table th {
            font-weight: 600;
            padding: 0.5em;
        }
        .highcharts-data-table td, .highcharts-data-table th, .highcharts-data-table caption {
            padding: 0.5em;
        }
        .highcharts-data-table thead tr, .highcharts-data-table tr:nth-child(even) {
            background: #f8f8f8;
        }
        .highcharts-data-table tr:hover {
            background: #f1f7ff;
        }

        .upperInfo {
            background: rgb(243, 238, 163);
            border-radius: 7px;
        }

        h5 {
            width:100%;
            margin-top:10px;
            font-family:'Ubuntu';
            padding:0.4em;
            
        }

        .firstEverInfo{             /* Informacion de primeros casos confirmados */

            background: rgb(241, 203, 159);
            border-radius: 7px;

        }

        .firstDeathsInfo{          /* Informacion de primeras muertes */

            background: rgb(236, 135, 104);
            border-radius: 7px;

            }

        h6 {
            width:100%;
            margin-top:10px;
            font-family:'Ubuntu';
            padding:0.4em;
            
        }

        .percentConfirmed{          /* Porcentajes de primeros casos */

            background: rgb(241, 203, 159);
            border-radius: 7px;

            }

        .percentDeath{              /* Porcentaje de muertes */

            background: rgb(236, 135, 104);
            border-radius: 7px;

            }

        #sidebar > div.leaflet-sidebar-tabs > ul:nth-child(1) > li.active > a > span {
            margin-top: 10px;
        }
        #sidebar > div.leaflet-sidebar-tabs > ul:nth-child(1) > li:nth-child(1) > a > span {
            margin-top: 10px;
        }

        
        @media (max-width: 769px) {
            h6 {
                font-size: 15px;
            }
        }

        @media (max-width: 769px) {
            h5 {
                font-size: 18px;
            }
        }
    </style>
</head>

<body>

<!-- SIDEBAR STARTS HERE //////////////////////////////////////////////////////////////////////////////////////////////////////7 -->
<!-- SIDEBAR STARTS HERE //////////////////////////////////////////////////////////////////////////////////////////////////////7 -->
<div id="sidebar" class="leaflet-sidebar collapsed">
    <!-- Nav tabs -->
    <div class="leaflet-sidebar-tabs">
        <ul role="tablist">
            <li><a href="#home" role="tab"><span class="fa fa-bars"></span></a></li>
        </ul>
    </div>

    <!-- Tab panes. -->
    <div class="leaflet-sidebar-content">
        <div class="leaflet-sidebar-pane" id="home">
            <p class="leaflet-sidebar-header">Resumen
                 <span class="leaflet-sidebar-close"><p class="fa-pulse">Close</p></span>
            </p>

            <h4 style="margin-bottom:1px; font-family:'Ubuntu',sans-serif; font-weight: bold;">Mapa Coronavirus Jujuy</br>(Actualizacion diaria)</br>(OJO ! Valores de Prueba!!!)</h4>
            <div class="upperInfo"> 
                <h5 id="totalConfirmed"></h5>   <!-- Total Casos Confirmados -->
                <h5 id="totalDeath"></h5>       <!-- Total Muertes     -->
                <h5 id="totalRecovered"></h5>   <!-- Total Recuperados -->
            </div>
            
            <div class="firstEverInfo"> 
                <h6 id="firstCases"></h6>   <!-- Primeros casos Confirmdos -->
            </div>

            <div class="percentConfirmed">
                <h6 id="topFive"></h6>      <!-- Top de 5 de cambios  % -->
            </div>

            <div class="firstDeathsInfo">
                <h6 id="firstDeath"></h6>   <!-- Muertes -->
            </div>
            

            <div class="percentDeath">
                <h6 id="topFiveDeath"></h6> <!-- Top 5 de muertes -->
            </div>

            <div id="container" style="width:100%; height:1000px;"></div>  <!-- Grafico Confirmados -->
            <div id="container2" style="width:100%; height:1000px;"></div> <!-- Grafico Muertes     -->

            <h6 style="background: none;">Nota</h6>
            <p style="margin-top:10px; font-family:'Ubuntu', sans-serif; line-height: 20px" align=justify >Hay 3 capas diferentes. </br>"Casos Confirmados" n√∫mero acumulado de individuos infectados en esas localidades. </br>"Muertes" n√∫mero acumulado de muertes causadas por la enfermedad. </br>"Recuperados" n√∫mero acumulado de personas que se recuperaron. </p>

            <h6 style="background: none;">Como utilizar el mapa</h6>
            <p style="margin-top:10px; font-family:'Ubuntu', sans-serif; line-height: 20px" align=justify >Las etiquetas dentro de los c√≠rculos representan el n√∫mero acumulado de personas. Haga clic en las opciones en la esquina superior derecha para cambiar entre capas. Para abrir ventanas emergentes con m√°s detalles, como el nombre de la localidad, y la fecha de los datos. </p>


            <h1 style="margin-top:60px; font-family:'Ubuntu' ,sans-serif; font-size:10px; line-height: 10px" align=justify >
                Fuente: Organismo origen de datos ....</h1>

        </div>

        <div class="leaflet-sidebar-pane" id="profile">
            <p class="leaflet-sidebar-header">Profile<span class="leaflet-sidebar-close"><i class="fa fa-caret-right"></i></span></p>
        </div>

        <div class="leaflet-sidebar-pane" id="messages">
            <p class="leaflet-sidebar-header">Messages<span class="leaflet-sidebar-close"><i class="fa fa-caret-right"></i></span></p>
        </div>

        <div class="leaflet-sidebar-pane" id="settings">
            <p class="leaflet-sidebar-header">Settings<span class="leaflet-sidebar-close"><i class="fa fa-caret-right"></i></span></p>
        </div>
    </div>
    <!-- FINAL DEL SIDEBAR DE LA DERECHA ///////////////////////////////////////////////////////////////////////////////////////// -->

</div>
<div id='map'></div>
<!--Side bar javascript file-->
<script src="assets/js/leaflet-sidebar.js"></script>
<!--Highcharts-->
<script src="https://code.highcharts.com/highcharts.js"></script>
<script src="https://code.highcharts.com/modules/series-label.js"></script>
<script src="https://code.highcharts.com/modules/exporting.js"></script>
<script src="https://code.highcharts.com/modules/export-data.js"></script>
<script src="https://code.highcharts.com/modules/accessibility.js"></script>

<!--Jquery-->
<script
        src="https://code.jquery.com/jquery-3.4.1.js"
        integrity="sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU="
        crossorigin="anonymous">
</script>
<!-- below is for bootstrap -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

<!-- for titling the layer groups-->
<script src="https://rawgithub.com/ismyrnow/Leaflet.groupedlayercontrol/master/src/leaflet.groupedlayercontrol.js"></script>
<!--Leaflet mapbox omnivore plugin for reading various formats including csv-->
<script src='https://api.mapbox.com/mapbox.js/plugins/leaflet-omnivore/v0.2.0/leaflet-omnivore.min.js'></script>

<!--CSV parser Papa parse-->
<script src="assets/js/papaparse.min.js"></script>


<!-- /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->
<script>
    window.onload= function () {

    /*various options for the basemap*/
    var grayscale = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 19
    });
    var CartoDB_DarkMatter = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 19
    });

    var Stadia_AlidadeSmoothDark = L.tileLayer('https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.png', {
        maxZoom: 20,
        attribution: '&copy; <a href="https://stadiamaps.com/">Stadia Maps</a>, &copy; <a href="https://openmaptiles.org/">OpenMapTiles</a> &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors'
    });
    var CartoDB_Voyager = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 19
    });
    var map = L.map('map', {
        zoom: 8,
        center: [-23.482695,-64.826953],
        layers: [grayscale]

    });


    var myRenderer = L.canvas({ padding: 0.1 });
    /* Defining icons in different shapes and colors for different layers*/

    var smallMedium_icon = {
        radius: 10,
        fillColor: "#feb24c",
        color: "#000",
        weight: 0.2,
        opacity: 1,
        fillOpacity: 0.8,
        renderer: myRenderer
    };


    var medium_icon = {
        radius: 14,
        fillColor: "#fc4e2a",
        color: "#000",
        weight: 0.2,
        opacity: 1,
        fillOpacity: 0.8,
        renderer: myRenderer
    };

    var mediumLarge_icon = {
        radius: 18,
        fillColor: "#e31a1c",
        color: "#000",
        weight: 0.2,
        opacity: 1,
        fillOpacity: 0.8,
        renderer: myRenderer
    };

    var large_icon = {
        radius: 22,
        fillColor: "#bd0026",
        color: "#000",
        weight: 0.2,
        opacity: 1,
        fillOpacity: 0.8,
        renderer: myRenderer
    };


    var small_icon_d = {
        radius: 10,
        fillColor: "#fcc5c0",
        color: "#000",
        weight: 0.2,
        opacity: 1,
        fillOpacity: 0.8,
        renderer: myRenderer
    };

    var medium_icon_d = {
        radius: 14,
        fillColor: "#f768a1",
        color: "#000",
        weight: 0.2,
        opacity: 1,
        fillOpacity: 0.8,
        renderer: myRenderer
    };

    var large_icon_d = {
        radius: 18,
        fillColor: "#ae017e",
        color: "#000",
        weight: 0.2,
        opacity: 1,
        fillOpacity: 0.8,
        renderer: myRenderer
    };


    var small_icon_r = {
        radius: 10,
        fillColor: "#7fcdbb",
        color: "000",
        weight: 0.2,
        opacity: 1,
        fillOpacity: 0.8,
        renderer: myRenderer
    };


    var medium_icon_r = {
        radius: 14,
        fillColor: "#1d91c0",
        color: "#000",
        weight: 0.2,
        opacity: 1,
        fillOpacity: 0.8,
        renderer: myRenderer
    };

    var large_icon_r = {
        radius: 18,
        fillColor: "#225ea8",
        color: "#000",
        weight: 0.2,
        opacity: 1,
        fillOpacity: 0.8,
        renderer: myRenderer
    };
    /* end of marker style (icon) definitions*/

    /*utilizing date functionality in js
    in order to autmatically update data*/
    let d = new Date();
    let year=d.getFullYear();
    year=year-2000;
    let month=d.getMonth();
    month=month+1;
    let day=d.getDate();
    /*if current day's data has not been
    uploaded check yesterday. And if yesterday's data has also not been
    uploade check the day before yesterday (tDB_yesterday)*/
    let yesterday=day-1;
    let tDb_Yesterday=day-2;
    /*part below written to re-assign month, yesterday and tDb_Yesterday
    variable with new value if current day is the first day of the month*/
    function firstDayOfTheMonth(){
        if (day==1 && month==1){
            tDb_Yesterday=30;
            yesterday=31;
            month=12
        }
        else if (day==1 && month==2){
            tDb_Yesterday=30;
            yesterday=31;
            month=1
        }
        else if (day==1 && month==3){
            tDb_Yesterday=28;
            yesterday=29;
            month=2
        }
        else if (day==1 && month==4){
            tDb_Yesterday=30;
            yesterday=31;
            month=3
        }
        else if (day==1 && month==5){
            tDb_Yesterday=29;
            yesterday=30;
            month=4
        }
        else if (day==1 && month==6){
            tDb_Yesterday=30;
            yesterday=31;
            month=5
        }
        else if (day==1 && month==7){
            tDb_Yesterday=29;
            yesterday=30;
            month=6
        }
        else if (day==1 && month==8){
            tDb_Yesterday=30;
            yesterday=31;
            month=7
        }
        else if (day==1 && month==9){
            tDb_Yesterday=30;
            yesterday=31;
            month=8
        }
        else if (day==1 && month==10){
            tDb_Yesterday=29;
            yesterday=30;
            month=9
        }
        else if (day==1 && month==11){
            tDb_Yesterday=30;
            yesterday=31;
            month=10
        }
        else if (day==1 && month==12){
            tDb_Yesterday=29;
            yesterday=30;
            month=11
        }
    }
    /*call the function*/
    firstDayOfTheMonth();

    /* string arguments to be used in geojson templates before using them as arguments for
    csv omnivore plugin*/
    let todayString=month+"/"+day+"/"+year;
    let yesterdayString=month+"/"+yesterday+"/"+year;
    let tDb_yesterdayString=month+"/"+tDb_Yesterday+"/"+year;

    let country="Localidad";

    /* first one, confirmed cases geojson custom layer*/
    let confirmedLayer = L.geoJson(null, {
        filter: function() {
            // no custom filter function but still keeping it
            return true;
        },
        /*points to the layer with the latest day's data from the csv*/
        pointToLayer (feature, layer) {
            if (feature.properties[todayString]&&feature.properties[country]!="Iran (Islamic Republic of)" && feature.properties[country]!="Mainland China"&&feature.properties[country]!="Republic of Korea"&&feature.properties[country]!="Czech Republic"){
                if (feature.properties[todayString]<1000 && feature.properties[todayString]!=0 ){
                    return L.circleMarker(layer, smallMedium_icon)
                }
                else if (feature.properties[todayString]>=1000 && feature.properties[todayString]<5000){
                    return L.circleMarker(layer,medium_icon)
                }
                else if (feature.properties[todayString]>=5000 && feature.properties[todayString]<10000){
                    return L.circleMarker(layer,mediumLarge_icon)
                }
                else if (feature.properties[todayString]>=10000){
                    return L.circleMarker(layer,large_icon)
                }
            } else if (feature.properties[yesterdayString]&&feature.properties[country]!="Iran (Islamic Republic of)" && feature.properties[country]!="Mainland China"&&feature.properties[country]!="Republic of Korea"&&feature.properties[country]!="Czech Republic") {
                if (feature.properties[yesterdayString]<1000 && feature.properties[yesterdayString]!=0 ){
                    return L.circleMarker(layer, smallMedium_icon)
                }
                else if (feature.properties[yesterdayString]>=1000 && feature.properties[yesterdayString]<5000){
                    return L.circleMarker(layer,medium_icon)
                }
                else if (feature.properties[yesterdayString]>=5000 && feature.properties[yesterdayString]<10000){
                    return L.circleMarker(layer,mediumLarge_icon)
                }
                else if (feature.properties[yesterdayString]>=10000){
                    return L.circleMarker(layer,large_icon)
                }
            }
            else if (feature.properties[tDb_yesterdayString]&&feature.properties[country]!="Iran (Islamic Republic of)" && feature.properties[country]!="Mainland China"&&feature.properties[country]!="Republic of Korea"&&feature.properties[country]!="Czech Republic") {
                if (feature.properties[tDb_yesterdayString]<100 && feature.properties[tDb_yesterdayString]!=0){
                    return L.circleMarker(layer, smallMedium_icon)
                }
                else if (feature.properties[tDb_yesterdayString]>=1000 && feature.properties[tDb_yesterdayString]<5000){
                    return L.circleMarker(layer,medium_icon)
                }
                else if (feature.properties[tDb_yesterdayString]>=5000 && feature.properties[tDb_yesterdayString]<10000){
                    return L.circleMarker(layer,mediumLarge_icon)
                }
                else if (feature.properties[tDb_yesterdayString]>=10000){
                    return L.circleMarker(layer,large_icon)
                }

            }


        },
        onEachFeature (feature, layer) {
            /*popup content*/
            if (feature.properties[todayString]){
                var content =  "<b>Departamento: </b>"+feature.properties["Departamento"]+"<br>"+"<b>Localidad: </b>"+feature.properties["Localidad"]+"<br>"+ "<b>Casos Confirmados: </b>"+feature.properties[todayString]+"<br>"+ "<b>Fecha del Dato: </b>"+[todayString];
                layer.bindPopup(content,{closeButton: false, offset:L.point(0,-5) });
                /* for labels inside circles*/
                var text = L.tooltip({
                    permanent: true,
                    direction: 'center',
                    className: 'text'
                })
                    .setContent(feature.properties[todayString])
                    .setLatLng(layer.getLatLng());
                layer.bindTooltip(text)

            }
            else if (feature.properties[yesterdayString]){
                /*popup content*/
                var content =  "<b>Departamento: </b>"+feature.properties["Departamento"]+"<br>"+"<b>Localidad: </b>"+feature.properties["Localidad"]+"<br>"+ "<b>Casos Confirmados: </b>"+feature.properties[yesterdayString]+"<br>"+ "<b>Fecha del Dato: </b>"+[yesterdayString];
                layer.bindPopup(content,{closeButton: false, offset:L.point(0,-5) });
                /* for labels inside circles*/
                var text = L.tooltip({
                    permanent: true,
                    direction: 'center',
                    className: 'text'
                })
                    .setContent(feature.properties[yesterdayString])
                    .setLatLng(layer.getLatLng());
                layer.bindTooltip(text)

            }
            else {
                /*popup content*/
                var content =  "<b>Departamento: </b>"+feature.properties["Departamento"]+"<br>"+"<b>Localidad: </b>"+feature.properties["Localidad"]+"<br>"+ "<b>Casos Confirmados: </b>"+feature.properties[tDb_yesterdayString]+"<br>"+ "<b>Fecha del Dato: </b>"+[tDb_yesterdayString];
                layer.bindPopup(content,{closeButton: false, offset:L.point(0,-5) });
                /* for labels inside circles*/
                var text = L.tooltip({
                    permanent: true,
                    direction: 'center',
                    className: 'text'
                })
                    .setContent(feature.properties[tDb_yesterdayString])
                    .setLatLng(layer.getLatLng());
                layer.bindTooltip(text)
            }
        },


    });

    /*deaths custom geojson layer*/
    let deathsLayer = L.geoJson(null, {
        filter: function() {
            // no custom filter function but still keeping it
            return true;
        },

        pointToLayer (feature, layer) {
            /*points to the layer with the latest day's data from the csv*/
            if (feature.properties[todayString] &&feature.properties[country]!="Iran (Islamic Republic of)" && feature.properties[country]!="Mainland China"&&feature.properties[country]!="Republic of Korea"&&feature.properties[country]!="Czech Republic"){
                if (feature.properties[todayString]<50 && feature.properties[todayString]!=0){
                    return L.circleMarker(layer, small_icon_d)
                }
                else if (feature.properties[todayString]>=50 && feature.properties[todayString]<500){
                    return L.circleMarker(layer,medium_icon_d)
                }
                else if (feature.properties[todayString]>=500){
                    return L.circleMarker(layer,large_icon_d)
                }
            } else if (feature.properties[yesterdayString]&&feature.properties[country]!="Iran (Islamic Republic of)" && feature.properties[country]!="Mainland China"&&feature.properties[country]!="Republic of Korea"&&feature.properties[country]!="Czech Republic") {
                if (feature.properties[yesterdayString]<50 && feature.properties[yesterdayString]!=0 ){
                    return L.circleMarker(layer, small_icon_d)
                }
                else if (feature.properties[yesterdayString]>=50 && feature.properties[yesterdayString]<500){
                    return L.circleMarker(layer,medium_icon_d)
                }
                else if (feature.properties[yesterdayString]>=500){
                    return L.circleMarker(layer,large_icon_d)
                }
            }
            else if (feature.properties[tDb_yesterdayString]&&feature.properties[country]!="Iran (Islamic Republic of)" && feature.properties[country]!="Mainland China"&&feature.properties[country]!="Republic of Korea"&&feature.properties[country]!="Czech Republic"){
                if (feature.properties[tDb_yesterdayString]<50 && feature.properties[tDb_yesterdayString]!=0 ){
                    return L.circleMarker(layer, small_icon_d)
                }
                else if (feature.properties[tDb_yesterdayString]>=50 && feature.properties[tDb_yesterdayString]<500){
                    return L.circleMarker(layer,medium_icon_d)
                }
                else if (feature.properties[tDb_yesterdayString]>=500){
                    return L.circleMarker(layer,large_icon_d)
                }

            }
        },
        onEachFeature (feature, layer) {
            /*popup content*/
            if (feature.properties[todayString]){
                /*popup content*/
                var content =  "<b>Pais/Region: </b>"+feature.properties["Departamento"]+"<br>"+"<b>Provincia: </b>"+feature.properties["Localidad"]+"<br>"+ "<b>Deaths: </b>"+feature.properties[todayString]+"<br>"+ "<b>Data Date: </b>"+[todayString];
                layer.bindPopup(content,{closeButton: false, offset:L.point(0,-5) });
                /* for labels inside circles*/
                var text = L.tooltip({
                    permanent: true,
                    direction: 'center',
                    className: 'text'
                })
                    .setContent(feature.properties[todayString])
                    .setLatLng(layer.getLatLng());
                layer.bindTooltip(text)

            }
            else if (feature.properties[yesterdayString]){
                /*popup content*/
                var content =  "<b>Pais/Region: </b>"+feature.properties["Departamento"]+"<br>"+"<b>Provincia: </b>"+feature.properties["Localidad"]+"<br>"+ "<b>Deaths: </b>"+feature.properties[yesterdayString]+"<br>"+ "<b>Data Date: </b>"+[yesterdayString];
                layer.bindPopup(content,{closeButton: false, offset:L.point(0,-5) });
                /* for labels inside circles*/
                var text = L.tooltip({
                    permanent: true,
                    direction: 'center',
                    className: 'text'
                })
                    .setContent(feature.properties[yesterdayString])
                    .setLatLng(layer.getLatLng());
                layer.bindTooltip(text)

            }
            else {
                /*popup content*/
                var content =  "<b>Pais/Region: </b>"+feature.properties["Departamento"]+"<br>"+"<b>Provincia: </b>"+feature.properties["Localidad"]+"<br>"+ "<b>Deaths: </b>"+feature.properties[tDb_yesterdayString]+"<br>"+ "<b>Data Date: </b>"+[tDb_yesterdayString];
                layer.bindPopup(content,{closeButton: false, offset:L.point(0,-5) });
                /* for labels inside circles*/
                var text = L.tooltip({
                    permanent: true,
                    direction: 'center',
                    className: 'text'
                })
                    .setContent(feature.properties[tDb_yesterdayString])
                    .setLatLng(layer.getLatLng());
                layer.bindTooltip(text)
            }


        },

    });

    /*recovered, custom geojson layer*/
    let recoveredLayer= L.geoJson(null, {
        filter: function() {
            // no custom filter function but still keeping it
            return true;
        },

        pointToLayer (feature, layer) {
            /*points to the layer with the latest day's data from the csv*/
            if (feature.properties[todayString]&&feature.properties[country]!="Iran (Islamic Republic of)" && feature.properties[country]!="Mainland China"&&feature.properties[country]!="Republic of Korea"&&feature.properties[country]!="Czech Republic"){
                if (feature.properties[todayString]<1000 && feature.properties[todayString]!=0){
                    return L.circleMarker(layer, small_icon_r)
                }
                else if (feature.properties[todayString]>=1000 && feature.properties[todayString]<2000){
                    return L.circleMarker(layer,medium_icon_r)
                }
                else if (feature.properties[todayString]>=2000){
                    return L.circleMarker(layer,large_icon_r)
                }
            } else if (feature.properties[yesterdayString]&&feature.properties[country]!="Iran (Islamic Republic of)" && feature.properties[country]!="Mainland China"&&feature.properties[country]!="Republic of Korea"&&feature.properties[country]!="Czech Republic") {
                if (feature.properties[yesterdayString]<1000 && feature.properties[yesterdayString]!=0){
                    return L.circleMarker(layer, small_icon_r)
                }
                else if (feature.properties[yesterdayString]>=1000 && feature.properties[yesterdayString]<2000){
                    return L.circleMarker(layer,medium_icon_r)
                }
                else if (feature.properties[yesterdayString]>=2000){
                    return L.circleMarker(layer,large_icon_r)
                }
            }
            else if (feature.properties[tDb_yesterdayString]&&feature.properties[country]!="Iran (Islamic Republic of)" && feature.properties[country]!="Mainland China"&&feature.properties[country]!="Republic of Korea"&&feature.properties[country]!="Czech Republic") {
                if (feature.properties[tDb_yesterdayString]<1000 && feature.properties[tDb_yesterdayString]!=0){
                    return L.circleMarker(layer, small_icon_r)
                }
                else if (feature.properties[tDb_yesterdayString]>=1000 && feature.properties[tDb_yesterdayString]<2000){
                    return L.circleMarker(layer,medium_icon_r)
                }
                else if (feature.properties[tDb_yesterdayString]>=2000){
                    return L.circleMarker(layer,large_icon_r)
                }

            }
        },
        onEachFeature (feature, layer) {
            /*popup content*/
            if (feature.properties[todayString]){
                var content =  "<b>Pais/Region: </b>"+feature.properties["Departamento"]+"<br>"+"<b>Provincia: </b>"+feature.properties["Localidad"]+"<br>"+ "<b>Recovered: </b>"+feature.properties[todayString]+"<br>"+ "<b>Data Date: </b>"+[todayString];
                layer.bindPopup(content,{closeButton: false, offset:L.point(0,-5) });
                /* for labels inside circles*/
                var text = L.tooltip({
                    permanent: true,
                    direction: 'center',
                    className: 'text'
                })
                    .setContent(feature.properties[todayString])
                    .setLatLng(layer.getLatLng());
                layer.bindTooltip(text)

            }
            else if (feature.properties[yesterdayString]){
                /*popup content*/
                var content =  "<b>Pais/Region: </b>"+feature.properties["Departamento"]+"<br>"+"<b>Provincia: </b>"+feature.properties["Localidad"]+"<br>"+ "<b>Recovered: </b>"+feature.properties[yesterdayString]+"<br>"+ "<b>Data Date: </b>"+[yesterdayString];
                layer.bindPopup(content,{closeButton: false, offset:L.point(0,-5) });
                /* for labels inside circles*/
                var text = L.tooltip({
                    permanent: true,
                    direction: 'center',
                    className: 'text'
                })
                    .setContent(feature.properties[yesterdayString])
                    .setLatLng(layer.getLatLng());
                layer.bindTooltip(text)

            }
            else {
                /*popup content*/
                var content =  "<b>Pais/Region: </b>"+feature.properties["Departamento"]+"<br>"+"<b>Provincia: </b>"+feature.properties["Localidad"]+"<br>"+ "<b>Recovered: </b>"+feature.properties[tDb_yesterdayString]+"<br>"+ "<b>Data Date: </b>"+[tDb_yesterdayString];
                layer.bindPopup(content,{closeButton: false, offset:L.point(0,-5) });
                /* for labels inside circles*/
                var text = L.tooltip({
                    permanent: true,
                    direction: 'center',
                    className: 'text'
                })
                    .setContent(feature.properties[tDb_yesterdayString])
                    .setLatLng(layer.getLatLng());
                layer.bindTooltip(text)
            }


        },

    });

    /*csv resources called and assigned to a variable*/
    //let confirmed= omnivore.csv('https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_19-covid-Confirmed.csv',null,confirmedLayer);
    let confirmed= omnivore.csv('./data/time_series_19-covid-Confirmed.csv',null,confirmedLayer);
//    let deaths= omnivore.csv('https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_19-covid-Deaths.csv',null,deathsLayer);
   let deaths= omnivore.csv('./data/time_series_19-covid-Deaths.csv',null,deathsLayer);
/*    let recovered= omnivore.csv('https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_19-covid-Recovered.csv',null,recoveredLayer); */
    let recovered= omnivore.csv('./data/time_series_19-covid-Recovered.csv',null,recoveredLayer);

    confirmed.addTo(map);

    var baseLayers = {
        //not any baselayers

    };

    //grouping overlaying features
    var overlayElements = {
        "Coronavirus": {
            "Casos Confirmados": confirmed,
            "Muertes": deaths,
            "Recuperados": recovered
        }
    };

    var options = {
        // Make the "Coronavirus" group exclusive (to use radio inputs)
        exclusiveGroups: ["Coronavirus"],
        // Show a checkbox next to non-exclusive group labels for toggling all
        groupCheckboxes: true,
        collapsed: false
    };

    L.control.groupedLayers(baseLayers, overlayElements, options).addTo(map);

    //colors to be used as palette for coloring the legend of confirmed layers
    function getColorConfirmed(y) {
        return y ==500 ? '#bd0026' :
            y ==400 ? '#e31a1c' :
                y==300 ? '#fc4e2a' :
                    y==200 ? '#feb24c' :
                        '#D04030';

    }

    //colors to be used as palette for coloring the legend of deaths layer
    function getColorDeaths(y) {
        return y==300 ? '#ae017e' :
            y==200 ? '#f768a1' :
                y==100 ? '#fcc5c0' :
                    '#D04030';

    }

    //colors to be used as palette for coloring the legend of recovered layer
    function getColorRecovered(y) {
        return y==300 ? '#225ea8' :
            y==200 ? '#1d91c0' :
                y==100 ? '#7fcdbb' :
                    '#D04030';

    }


    //calculate radius so that resulting circles will be proportional by area
    function getRadius(y) {
        r = Math.sqrt(y / Math.PI);
        return r;
    }

    //defining legends
    var confirmedLegend= L.control({position: 'bottomleft'});

    var deathsLegend= L.control({position: 'bottomleft'});

    var recoveredLegend= L.control({position: 'bottomleft'});

    //creating all legends
    confirmedLegend.onAdd = function (map) {

        var div = L.DomUtil.create('div', 'info legend'),
            grades = [200, 300,400,500],
            labels2=[0,1000,5000,10000],
            labels = ['<strong>Leyenda</strong>', "Casos Confirmados"],
            from, to;
        //iterate through grades and create a color field and label for each
        for (var i = 0; i < grades.length; i++) {

            from = grades[i];
            to = grades[i + 1];

            labels.push( '<i class="circlepadding" style="width: '+Math.max(0,(40-1.8*getRadius(from)))+'px;"></i> <i style="background:'+ getColorConfirmed(from)+'; width: '+getRadius(from)*2+'px; height: '+getRadius(from)*2+'px; border-radius: 50%; margin-top: '+Math.max(0,(9-getRadius(from)))+'px;"></i> ' + labels2[i]+(labels2[i+1] ? '&ndash;' + labels2[i+1] : '+'));
        }
        div.innerHTML = labels.join('<br>');
        return div;
    };


    deathsLegend.onAdd = function (map) {

        var div = L.DomUtil.create('div', 'info legend'),
            grades = [100, 200, 300],
            labels2=[0,50,500],
            labels = ['<strong>Leyenda</strong>', "Muertes"],
            from, to;
        //iterate through grades and create a color field and label for each
        for (var i = 0; i < grades.length; i++) {

            from = grades[i];
            to = grades[i + 1];

            labels.push( '<i class="circlepadding" style="width: '+Math.max(0,(40-1.8*getRadius(from)))+'px;"></i> <i style="background:'+ getColorDeaths(from)+'; width: '+getRadius(from)*2+'px; height: '+getRadius(from)*2+'px; border-radius: 50%; margin-top: '+Math.max(0,(9-getRadius(from)))+'px;"></i> ' + labels2[i]+(labels2[i+1] ? '&ndash;' + labels2[i+1] : '+'));
        }
        div.innerHTML = labels.join('<br>');
        return div;



    };

    recoveredLegend.onAdd = function (map) {


        var div = L.DomUtil.create('div', 'info legend'),
            grades = [100, 200, 300],
            labels2=[0,1000,2000],
            labels = ['<strong>Leyenda</strong>', "Recuperados"],
            from, to;
//iterate through grades and create a color field and label for each
        for (var i = 0; i < grades.length; i++) {

            from = grades[i];
            to = grades[i + 1];

            labels.push( '<i class="circlepadding" style="width: '+Math.max(0,(40-1.8*getRadius(from)))+'px;"></i> <i style="background:'+ getColorRecovered(from)+'; width: '+getRadius(from)*2+'px; height: '+getRadius(from)*2+'px; border-radius: 50%; margin-top: '+Math.max(0,(9-getRadius(from)))+'px;"></i> ' + labels2[i]+(labels2[i+1] ? '&ndash;' + labels2[i+1] : '+'));
        }
        div.innerHTML = labels.join('<br>');
        return div;

    };

    //initally add first layer's legend on the main page
    confirmedLegend.addTo(map);

    //conditional add/remove of legends
    confirmed.beforeAdd = function (map) {
        confirmedLegend.addTo(map);
        deathsLegend.remove(map);
        recoveredLegend.remove(map);
    };
    deaths.beforeAdd = function (map) {
        deathsLegend.addTo(map);
        confirmedLegend.remove(map);
        recoveredLegend.remove(map);
    };

    recovered.beforeAdd=function(map){
        deathsLegend.remove(map);
        confirmedLegend.remove(map);
        recoveredLegend.addTo(map);
    };

    //Agregando el side bar
    var sidebar = L.control.sidebar({ container: 'sidebar', position: 'right' })
        .addTo(map)
        .open("home");

    //GRAPH, DATA OPERATIONS para Confirmados /////////////////////////////////////////////////////////////////////////////////////
    //GRAPH, DATA OPERATIONS para Confirmados /////////////////////////////////////////////////////////////////////////////////////
    let worldTotal_Confirmed=0
    let confirmedLabels=[];
    let confirmedValues=[];
   
    let confirmedValues_OneDayAgo=[];
    //Para encontrar total de casos en US,China,Canada and Australia
    let totalConfirmed_US=0;
    let totalConfirmed_China=0;
    let totalConfirmed_Canada=0;
    let totalConfirmed_Aus=0;
    //para encontrar el cambio diario %
    let totalConfirmed_US_OneDayAgo=0;
    let totalConfirmed_China_OneDayAgo=0;
    let totalConfirmed_Canada_OneDayAgo=0;
    let totalConfirmed_Aus_OneDayAgo=0;
    //proceso de carga de casos confirmados en un formato array, dentro de los arrays vacios definidos mas arriba

    /*Papa.parse("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_19-covid-Confirmed.csv", {*/
    Papa.parse("./data/time_series_19-covid-Confirmed.csv", {
        download: true,
        complete: function(results) {
            //select la ultima columna
            let lastCol=results.data[1].length-1;
            //select la columna anterior a la ultima para usarlo en el calculo del cambio daily % change
            let last2Col=results.data[1].length-2;

            for (i=1; i< results.data.length; i++) {

                    var nmbr_OneDayAgo=parseInt(results.data[i][last2Col]);
                    var nmbr=parseInt(results.data[i][lastCol]);
                    confirmedValues.push(nmbr);
                    confirmedLabels.push(results.data[i][0])
                    confirmedValues_OneDayAgo.push(nmbr_OneDayAgo)
            }

            //console.log(confirmedValues_OneDayAgo)
            //console.log(confirmedValues)
            let percentChangeDailyArray=[]
            //calculate daily change compared to data from the day before
            function DailyChange(){
            for (n = 0; n < confirmedValues.length; n++) {
                    let perc= Math.round((confirmedValues[n]-confirmedValues_OneDayAgo[n])*100/confirmedValues_OneDayAgo[n])
                    if (perc==Infinity) {
                        percentChangeDailyArray.push("Primer Case")
                    }
                    else {
                        percentChangeDailyArray.push(perc)
                    }
                    }
                }


            DailyChange();


            //console.log(percentChangeDailyArray)

            //zip values from both lists
            var zippedPercDailyChange = confirmedLabels.map(function(e, i) {
                return [e, percentChangeDailyArray[i]];
            });
            //sort descending percent change
            zippedPercDailyChange.sort(function(a,b){return b[1]-a[1];});
            //console.log(zipped)

             let newCases=[]
            //finding countries with the first ever cases
            function SelectNewCases(){

                for (p=0; p<zippedPercDailyChange.length; p++) {

                    if (zippedPercDailyChange[p][1]=="First Case") {

                        newCases.push(zippedPercDailyChange[p][0])

                    }
                    

                }

                

            }
            SelectNewCases()
            //Si no hay nuevas localidades
            if (newCases.length==0) {
                    newCases.push("N/A por hoy")
                }

            //slice localidades con el top 5 de % de cambio diario
            let topFive=[]
            function selectTopFive() {
                topFive=zippedPercDailyChange.slice(1,6)
            }
            selectTopFive()

            //put them in a format that will be displayed properly to the user
            var topFiveString="";
            function createString(){
                for (v=0;v<topFive.length;v++){
                    topFiveString+=topFive[v][0]
                    topFiveString+=" "
                    topFiveString+=topFive[v][1]
                    topFiveString+="%  -   "
                }
            }
            createString()
            //console.log(topFiveString)

            //push the values the document
            document.getElementById("firstCases").innerHTML="<b>Localidades que anunciaron recientemente los primeros casos confirmados dentro de sus fronteras:</b> "+"</br>"+newCases

            document.getElementById("topFive").innerHTML="<b>Localidades con el mayor porcentaje de cambio diario en casos confirmados: </b> "+"</br>"+topFiveString


            //zip values from both lists
            var c = confirmedLabels.map(function(e, i) {
                return [e, confirmedValues[i]];
            });
            //sort descending
            c.sort(function(a,b){return b[1]-a[1];});
            //console.log(c)

            //create new lists to separate and store the sorted data
            sortedConfirmedLabels=[];
            sortedConfirmedValues=[];

            function separateValues() {
                for (n = 0; n < c.length; n++) {
                    sortedConfirmedLabels.push(c[n][0])
                }

                for (n = 0; n < c.length; n++) {
                    sortedConfirmedValues.push(c[n][1])
                }
            }

            separateValues()

            //TODO EL TOTAL CONFIRMADO INDEPENDIENTE DE LA LOCALIDAD
            let worldTotal_Confirmed=0
            function totalGlobal_Confirmed() {
                for (n = 0; n < c.length; n++) {
                    worldTotal_Confirmed+=c[n][1]
            }
            return worldTotal_Confirmed
            }
            totalGlobal_Confirmed()
            
            //splitting the number visually from 1000's
            partsOfValue=[]
            while (worldTotal_Confirmed>1000) {
                worldTotal_Confirmed=worldTotal_Confirmed/1000
                partsOfValue.push(Math.floor(1000*((worldTotal_Confirmed) - Math.floor(worldTotal_Confirmed))))

                if (worldTotal_Confirmed<1000) {
                    partsOfValue.push(Math.floor(1000*(worldTotal_Confirmed/1000)))
                }
                
            }
            partsOfValue.reverse()


           let worldTotal_Confirmed_String="";
           //console.log(partsOfValue.length)
            function stringCreate() {
               for (m=0; m<partsOfValue.length; m++){
                worldTotal_Confirmed_String=worldTotal_Confirmed_String+" "+partsOfValue[m]
                //console.log(worldTotal_Confirmed_String)
           }
           return worldTotal_Confirmed_String
           }
           stringCreate();
           //console.log(worldTotal_Confirmed_String)

           document.getElementById("totalConfirmed").innerHTML="<b>Total Casos Confirmados:</b> "+worldTotal_Confirmed_String
            //console.log(sortedConfirmedLabels)
            //console.log(sortedConfirmedValues)

            Highcharts.chart('container', {
                chart: {
                    type: 'bar'
                },
                title: {
                    text: 'CASOS CONFIRMADOS COVID-19'
                },
                subtitle: {
                    text: 'Total Confirmado por Localidad'
                },
                xAxis: {
                    categories: sortedConfirmedLabels,
                    title: {
                        text: null
                    }
                },
                yAxis: {
                    min: 0,
                    title: {
                        text: 'Numero de Personas',
                        align: 'high'
                    },
                    labels: {
                        overflow: 'justify'
                    }
                },
                tooltip: {
                    valueSuffix: ' '
                },
                plotOptions: {
                    bar: {
                        dataLabels: {
                            enabled: true
                        }
                    }
                },
                /*legend: {
                    layout: 'vertical',
                    align: 'right',
                    verticalAlign: 'top',
                    x: -40,
                    y: 80,
                    floating: true,
                    borderWidth: 1,
                    backgroundColor:
                        Highcharts.defaultOptions.legend.backgroundColor || '#FFFFFF',
                    shadow: true
                },*/
                credits: {
                    enabled: false
                },
                series: [{
                    name: 'Casos Confirmados',
                    data:sortedConfirmedValues,
                    color: '#feb24c'

                }]
            });

        },


    });

    

    //GRAPH, DATA OPERATIONS para MUERTES  //////////////////////////////////////////////////////////////////////////////////////////
    //GRAPH, DATA OPERATIONS para MUERTES  //////////////////////////////////////////////////////////////////////////////////////////
    let worldTotal_Deaths=0
    let deathsLabels=[];
    let deathsValues=[];
    let deathsLabels_OneDayAgo=[];
    let deathsValues_OneDayAgo=[];

    //putting death cases into array format, into the empty arrays defined above

    /*   Papa.parse("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_19-covid-Deaths.csv", { */
    Papa.parse("./data/time_series_19-covid-Deaths.csv", {
        download: true,
        complete: function(results) {
            //Selecciono las ultimas columnas
            let lastCol =results.data[1].length-1;
            let last2Col=results.data[1].length-2;

            for (i=1; i< results.data.length; i++) {  
                    var nmbr_OneDayAgo=parseInt(results.data[i][last2Col]);
                    var nmbr=parseInt(results.data[i][lastCol]);
                    //console.log(nmbr)
                    deathsValues_OneDayAgo.push(nmbr_OneDayAgo);
                    deathsValues.push(nmbr);
                    deathsLabels.push(results.data[i][0])
            }

    /////////////////////////////////////////////////////
            let percentChangeDailyArray=[]
            //calcular el cambio diario en comparaci√≥n con los datos del d√≠a anterior
            function DailyChange(){
            for (n = 0; n < deathsValues.length; n++) {
                    let perc= Math.round((deathsValues[n]-deathsValues_OneDayAgo[n])*100/deathsValues_OneDayAgo[n])
                    if (perc==Infinity) {
                        percentChangeDailyArray.push("Primera Muerte")
                    }
                    else if (Number.isNaN(perc)) {
                        percentChangeDailyArray.push(0)
                    } else {
                        percentChangeDailyArray.push(perc)
                    }
                    }
                }

            DailyChange();

            //console.log(percentChangeDailyArray)

            //zip values from both lists
            var zippedPercDailyChange = deathsLabels.map(function(e, i) {
                return [e, percentChangeDailyArray[i]];
            });
            //Ordenar porcentaje de cambio de forma descendente
            zippedPercDailyChange.sort(function(a,b){return b[1]-a[1];});
            //console.log(zippedPercDailyChange)

             let firstDeath=[]
            //Encontrando localidades con los primeros casos
            function SelectNewDeath(){
                for (p=0; p<zippedPercDailyChange.length; p++) {
                    if (zippedPercDailyChange[p][1]=="Primera Muerte") {
                        firstDeath.push(zippedPercDailyChange[p][0])
                    }
                }
            }
            SelectNewDeath()
            //Si no hay nuevas localidsdes
            if (firstDeath.length==0) {
                    firstDeath.push("N/A")
                }

            //slice localiddes en el top 5 de % de cambio diario 
            let topFive=[]
            function selectTopFive() {
                topFive=zippedPercDailyChange.slice(1,6)
            }
            selectTopFive()

            //Los ponemos en un formato array para ser mostrado en pantalla 
            var topFiveString="";
            function createString(){
                for (v=0;v<topFive.length;v++){
                    topFiveString+=topFive[v][0]
                    topFiveString+=" "
                    topFiveString+=topFive[v][1]
                    topFiveString+="%  -   "
                }
            }
            createString()
            //console.log(topFiveString)

            //Mostramos los valores en la pantalla 
            document.getElementById("firstDeath").innerHTML="<b>Localidades que anunciaron recientemente el primer caso de muerte dentro de sus fronteras:</b> "+"</br>"+firstDeath

            document.getElementById("topFiveDeath").innerHTML="<b>Localidades con el mayor porcentaje de cambio diario en muertes: </b> "+"</br>"+topFiveString
            ////////////////////////////////////////////////////////////////////////
           

            //zip values from both lists
            var c = deathsLabels.map(function(e, i) {
                return [e, deathsValues[i]];
            });
            //sort descending
            c.sort(function(a,b){return b[1]-a[1];});
            console.log(c)

            //Crea nuevas listas para separar y ordenar los datos
            sortedDeathLabels=[];
            sortedDeathValues=[];

            function separateValues() {
                for (n = 0; n < c.length; n++) {
                   if (c[n][1]!=0){
                    sortedDeathLabels.push(c[n][0])
                   }
                }

                for (n = 0; n < c.length; n++) {
                    if (c[n][1]!=0){
                    sortedDeathValues.push(c[n][1])
                    }
                }
            }

            separateValues()

            //Todo el total de Casos Confirmados, sin importar la localidad
            let worldTotal_Deaths=0
            function totalGlobal_Deaths() {
                for (n = 0; n < c.length; n++) {
                    worldTotal_Deaths+=c[n][1]
            }
            return worldTotal_Deaths
            }
            totalGlobal_Deaths()
            
            //splitting the number visually from 1000's
            partsOfValue=[]
            while (worldTotal_Deaths>1000) {
                worldTotal_Deaths=worldTotal_Deaths/1000
                partsOfValue.push(Math.floor(1000*((worldTotal_Deaths) - Math.floor(worldTotal_Deaths))))

                if (worldTotal_Deaths<1000) {
                    partsOfValue.push(Math.floor(1000*(worldTotal_Deaths/1000)))
                }
                
            }
            partsOfValue.reverse()

           let worldTotal_Deaths_String="";
           //console.log(partsOfValue.length)
            function stringCreate() {
               for (m=0; m<partsOfValue.length; m++){
                worldTotal_Deaths_String=worldTotal_Deaths_String+" "+partsOfValue[m]
                
           }
           return worldTotal_Deaths_String
           }

           stringCreate()

            document.getElementById("totalDeath").innerHTML="<b>Total Muertes:</b> "+worldTotal_Deaths_String

            //console.log(sortedConfirmedLabels)
            //console.log(sortedConfirmedValues)

            Highcharts.chart('container2', {
                chart: {
                    type: 'bar'
                },
                title: {
                    text: 'Muertes'
                },
                subtitle: {
                    text: 'Muertes por Loccalidad'
                },
                xAxis: {
                    categories: sortedDeathLabels,
                    title: {
                        text: null
                    }
                },
                yAxis: {
                    min: 0,
                    title: {
                        text: 'Numbero de Personas',
                        align: 'high'
                    },
                    labels: {
                        overflow: 'justify'
                    }
                },
                tooltip: {
                    valueSuffix: ' '
                },
                plotOptions: {
                    bar: {
                        dataLabels: {
                            enabled: true
                        }
                    }
                },
                /*legend: {
                    layout: 'vertical',
                    align: 'right',
                    verticalAlign: 'top',
                    x: -40,
                    y: 80,
                    floating: true,
                    borderWidth: 1,
                    backgroundColor:
                        Highcharts.defaultOptions.legend.backgroundColor || '#FFFFFF',
                    shadow: true
                },*/
                credits: {
                    enabled: false
                },
                series: [{
                    name: 'Muertes',
                    data:sortedDeathValues,
                    color:"#fc4e2a"

                }]
            });
                
        },
    });

     //GRAPH, DATA OPERATIONS for RECUPERADOS  ////////////////////////////////////////////////////////////////////////////////////
     //GRAPH, DATA OPERATIONS for RECUPERADOS  ////////////////////////////////////////////////////////////////////////////////////
    let worldTotal_Recovered=0
    let recoveredLabels=[];
    let recoveredValues=[];

    //putting confirmed cases into array format, into the empty arrays defined above

/*    Papa.parse("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_19-covid-Recovered.csv", { */
    Papa.parse("./data/time_series_19-covid-Recovered.csv", {
        download: true,
        complete: function(results) {
            //select the latest column
            let lastCol=results.data[1].length-1;

            for (i=1; i< results.data.length; i++) {

                    var nmbr=parseInt(results.data[i][lastCol]);
                    recoveredValues.push(nmbr);
                    recoveredLabels.push(results.data[i][0])

            }

            //console.log(confirmedLabels+"\n"+confirmedValues)

            //zip values from both lists
            var c = recoveredLabels.map(function(e, i) {
                return [e, recoveredValues[i]];
            });
            //sort by country names
            c.sort();
            //console.log(c)

            //create new lists to separate and store the sorted data
            sortedRecoveredLabels=[];
            sortedRecoveredValues=[];

            function separateValues() {
                for (n = 0; n < c.length; n++) {
                    sortedRecoveredLabels.push(c[n][0])
                }

                for (n = 0; n < c.length; n++) {
                    sortedRecoveredValues.push(c[n][1])
                }
            }

            separateValues()

            //all total confirmed regardless of country
            let worldTotal_Recovered=0
            function totalGlobal_Recovered() {
                for (n = 0; n < c.length; n++) {
                    worldTotal_Recovered+=c[n][1]
            }
            return worldTotal_Recovered
            }
            totalGlobal_Recovered()
           

            //splitting the number visually from 1000's
            partsOfValue=[]
            while (worldTotal_Recovered>1000) {
                worldTotal_Recovered=worldTotal_Recovered/1000
                partsOfValue.push(Math.floor(1000*((worldTotal_Recovered) - Math.floor(worldTotal_Recovered))))

                if (worldTotal_Recovered<1000) {
                    partsOfValue.push(Math.floor(1000*(worldTotal_Recovered/1000)))
                }
                
            }
            partsOfValue.reverse()


           let worldTotal_Recovered_String="";
           //console.log(partsOfValue.length)
            function stringCreate() {
               for (m=0; m<partsOfValue.length; m++){
                worldTotal_Recovered_String=worldTotal_Recovered_String+" "+partsOfValue[m]
                //console.log(worldTotal_Recovered_String)
           }
           return worldTotal_Recovered_String
           }
           stringCreate();
           document.getElementById("totalRecovered").innerHTML="<b>Total Recuperados: </b>"+worldTotal_Recovered_String

            //console.log(sortedConfirmedLabels)
            //console.log(sortedConfirmedValues)

        },

    });

    };

</script>
</body>
</html>
